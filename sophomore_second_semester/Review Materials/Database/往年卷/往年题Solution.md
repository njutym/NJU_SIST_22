> wyh 2022.5.9

## 2014 非代码题

#### 一、论述题

##### 2. 解释硬解析和软解析的含义和区别

- 硬解析指使用优化器对SQL进行优化，将SQL转化为一些等效语句，并选择代价最小的语句生成执行计划；
- 软解析是指共享池中已经存在由对应的执行计划，则不再优化，直接使用该执行计划；
- 硬解析代价大，软解析代价较小；

##### 3. 将类似的SQL由硬解析变成软解析的技术成为什么？

Oracle的自适应游标共享。

##### 4. 举例说明

```sql
select * from test where object_id=20;
select * from test where object_id=30;
```

和

```sql
exec :oid:=20;
select * from test where object_id=:oid;
exec :oid:=30;
select * from test where object_id=:oid;
```

每次查询会对SQL查询文本计算一个哈希值，存在共享池；每次查询会比对这个哈希值，如果有匹配到的目标，就从共享池中取出对应的执行计划。

#### 二、请详细描述关于数据库范式和逆范式(或称为反范式)的以下几个问题

1. 什么是逆范式？逆范式是为了放弃规范化，控制冗余
2. 你认为判断何时该使用逆范式的条件有哪些？系统有相对比较低的修改率和较高的查询率时可以选择打破范式。
   - 情况1：合并一对一关系，可能会导致NULL、大量空间浪费等问题。
   - 情况2：一对多关系复制非关键字属性，例如订单的金额和货品的金额，一般会使用触发器来同步修改属性。
   - 情况3：一对多关系复制外部关键字，如果实体A访问实体C一定要通过实体B，那么我们可以在C中复制关键字A，直接关联避开B
   - 情况4：多对多关系复制属性：将title、用户名等信息添加到关联关系中
   - 情况5：引入重复组：引入地址、电话号码等，主表中可以存放一个缺省的地址和电话号码来避开连接查询
   - 情况6：创建提取表：合并基本表和查找表
   - 情况7：分区

#### 三、DBMS中索引有很多种，请简述下列问题

##### 1）位图索引的存储结构和用途

存储结构：

1. 位图索引的索引存储指向多行的指针；
2. 位图索引每次进行修改都会锁住全部的索引；

用途：

1. 相异基数低：字段可以取用的值比较少；
2. 大量临时查询的聚合；

##### 2）函数索引的含义和用途

含义：对$F(x)$的值构建索引，在通过对索引读取$x$所指向的记录行；

用途：

1. 不区分大小写的查询：使用函数输入；
2. T、F的巨大差异下的索引：如何找到少量的F；
3. 有选择的唯一性：Active的活动的名称不能相同；

##### 3）反向键索引或逆向索引的含义和用途

含义：将索引的字段翻转过来作为索引的键值；

用途：用来解决高并发下的系统生成键的创建和插入问题；

##### 4）还知道什么索引？

B+树索引、哈希索引、聚簇索引、辅助索引、稀疏索引（部分数据建立索引）、密集索引（全部）

#### 四、同2015二

#### 七、树状结构数据

##### 1）三种存储设计方案：

邻接模型、物化路径模型、嵌套集合模型

##### 2）设计一个简单的例子进行表述：

自顶向下：

```sql
select t.name, t.id   
from tree t  
start with t.id = 'top' 
CONNECT BY PRIOR t.id = t.parent_id  
order SIBLINGS by t.order_no;
```

自底向上：

```sql
from tree t  
start with t.id = 'top' 
CONNECT BY PRIOR t.parent_id = t.id  
order SIBLINGS by t.order_no
```



## 2015 非代码题

#### 一、请简要描述在DBMS中SQL语句的执行过程，并简单对各个步骤所花费的代价进行描述和比较。

1. **语法分析**

   分析语句的语法是否符合规范；衡量语句中各个表达式的意义；

2. **语义分析**

   检查语句中设计的所有数据库对象是否存在，且用户有相应的权限；

3. **执行解析**

   优化器对每一个表达式的等价变化生成解析树，然后进行评估，由优化器选择一个最优的执行路径来生成执行计划。

   执行路径选择中会经历：

   1. **视图转换**

      将涉及视图的查询语句转换为相应的对基表查询语句；

   2. **表达式转换**

      将复杂的SQL表达式转换为较简单的等效连接表达式；

   3. **选择优化器**

      不同的优化器一般会生成不同的“执行计划”；

   4. **选择连接方式**

      对多表连接选择适当的连接方式；

   5. **选择连接顺序**

      对多表连接，选择哪一对表先连接，选择这两表中哪个表作为源数据表；

   6. **选择数据的搜索路径**

      根据以上条件选择合适的数据搜索路径，如果是选用全表搜索还是利用索引或者是其他的运行方式；

4. **运行“执行计划”**

语法分析：分析语法是否符合规范，代价小；

语义分析：分析语句含义，检查用户对数据库是否有相应权限，代价小；

解析：分为硬解析和软解析。若在共享池中没找到已有的执行计划则硬解析，否则软解析。硬解析指使用优化器对SQL语句进行优化，将SQL转化为一些等价语句，并选择代价最小的语句生成执行计划。软解析指在共享池中已经存在对应的执行计划，则不再进行优化，直接使用该执行计划。硬解析的代价最大，软解析较小。

执行计划，返回执行结果。代价根据SQL语句不同可大可小。

#### 二、B+Tree索引是大多DBMS缺省的索引类型，请详细描述以下几个问题：

##### 1）B树索引的结构和使用方式

有K个子树的中间结点包含K个元素，每个节点不保存数据只保存索引，所有的数据都存储在叶节点；

所有叶节点中包含了元素的信息，还有指向元素记录的指针，并且叶节点本身按照关键字大小从小到大的顺序连接；

使用方式是根据目标元素在B树中二分查找。

##### 2）何时该使用B树索引，并分别说明原因；并详细说明为什么系统的为外键构建索引是普遍的要求？

何时使用：

- 仅需要通过索引访问基本表的一部分（检索的结果集与集体的百分比低于10%）
- 如果处理表的多列，可以使用索引而不使用表；

为什么系统的为外键构建索引是普遍的要求：

- 建立外键索引可以更快速地保证数据的一致性：比如A持有B的外键，B删除记录时需要检查A中相应的行；否则，需要对A全表遍历；
- 建立外键索引可以避免死锁：如上所述，对A全表遍历时间很长，导致其他进程与之死锁，导致双双失败；

##### 3）针对2）有没有例外情况？如果有请简要说明情况

如果表很小或者很少被修改，则不必建立；因为使用索引非常占用磁盘空间；

##### 4）请描述Oracle中一种类似于B树索引结构的物理组织形式索引组织表（IOT）的基本结构和应用范围

其中的记录是排序，按主键有序的。IOT中每个叶节点既有每行的主键值，又有非主键值。

数据的存放是严格规定的， 记录的存放是排序的，查询效率非常高。数据插入以前其实就已经确定了其位置，所以不管插入的先后顺序，它在那个物理上的哪个位置与插入的先后顺序无关。这样在进行查询的时候就可以少访问很多 blocks，但是插入的时候，速度就比普通的表要慢一些。

应用范围：经常查找的表；经常通过主键访问的表；按顺序进行物理存贮；构建自己的索引结构；对主键或者唯一键区间查询、分类查询；

不适用：经常更新的表；不经常使用主键访问的表；

#### 五、请举例描述邻接模型和物化路径模型将树状结构存储到关系表结构的设计方法，并通过不同的查询（包括自顶向下的查询、自底向上的查询、集合查询）来比较不同表结构设计下SQL的效率。

设计方法：

1. 邻接模型：
   - 层次中父节点id作为子节点id的一个属性pid，不能确定兄弟节点的排序；
   - 难以处理的，是递归的；
   - 任何的CRUD操作都是低效的；
2. 物化路径模型：
   - 将树中间的每一个节点和在树中的位置描述成数据的结合；
   - 是所有子节点的祖先节点的id的串联；
   - 能够知道兄弟节点之间的排名，家谱；
   - 较为高效，使用空间换时间；

父子结构（树状结构）和主从结构两种，二者的差异是：

- 树状结构只需要保存一张表：代表层次的树。
- 主从结构没有深度的概念。主从结构可以明确外键完整性约束，但是树状结构不需要定义所有权。



## 2019 非代码题

#### 一、关系理论

数据库中的表描述了关系，表的字段之间存在关系；从理论上保证一致性；

##### 1）为什么说关系数据库比层状/网状数据库更科学？

- 层次性数据库最早出现：存在逻辑嵌套，而不是线性排列，适用于部分场景，耦合性过强限制了我们对数据的自由操作；
- 网状数据库（多层次链接）：灵活很多，但是数据操作依然困难；
- 关系型数据库在灵活性、数据访问、数据的组织找到了很好的平衡点，说场景普适的存储方式，对于特定的存储不太合适；

##### 2）关系理论认为，数据中不应该有重复数据，记录之间也不存在顺序关系。在现实的关系型数据库中又是如何处理的？

关系理论不包含重复数据，不然无法保证一致性。然而很多中间结果集包含重复数据。因为：关系是处理无限数据集的，但是数据库处理的是有限数据集。有限数据集不仅需要保证正确，还需要提高效率。

额外：关系理论中，记录没有顺序。现实的关系型数据库中顺序存放记录使得效率提高；

##### 3）关系理论中的空值和实际关系型数据库中空值的处理有何差异？

“不知道”。空值对程序逻辑是危险的；存在空值意味着关系模型存在严重问题，动摇了查询优化的基础。

#### 二、索引

##### 1）什么是索引？

索引是关系数据库中对某一列或多个列的值进行预排序的数据结构；

##### 2）哈希索引的结构和使用范围

结构：对索引键值进行哈希计算，将得到的结果作为键值创建索引；

使用范围：支持全键值查询、=、in、不等于等运算；不支持部分键值匹配、排序；

##### 3）避免哈希冲突：使用二次哈希或者拉链法；

#### 三、魔药设计

我猜是树状结构设计。

#### 四、高并发

##### 1）锁的解决方案是什么样的？

- 不要随便使用表级锁，尽量使用细粒度锁；
- 只有使用了索引才能使用行锁；
- 尽量缩短加锁时间
- 避免SQL上的循环处理；
- 减少程序和数据库之间的交互次数；
- 先roll back，提前释放锁；

##### 2）解决资源竞争的方法有哪些？

- DBA解决方案：与业务逻辑弱相关或无关
  - 事务空间：调整事物锁占空间的大小，事务条目占用是重要原因，DBA可以增加分配给事务条目的空间来解决；
  - 可用列表：insert操作在不同物理块中，可以借助存储管理手段；
- 架构解决方案：
  - 分区；
  - 逆序索引；减少竞争点
  - 索引组织表：原本资源竞争包括基本表和索引，但是现在索引和基本表合并了，可以降低冲突发生的位置；
- 开发解决方案
  - 调节并发数：限制最高的session数量；多加session反倒会增加管理成本；
  - 不适用系统产生键：如果键没有意义，不妨使用随机值，range需要足够大；碰撞

#### 六、简述优化器的工作原理和局限性

- 工作原理：解析过程的6个步骤；
- 局限性：
  - 查询优化器不能发现SQL本身表达逻辑错误；
  - 查询优化器不能优化查询的中间结果集；



## 代码题合集

#### 一、船只租赁系统

表结构如下：

```sql
Sailors(sid, sname, rating, age);
Boats(bid, bname, color);
Reaserves(sid, bid, day);
```

用完整的SQL语句，利用嵌套查询来完成1）2）两个查询，并从SQL优化的角度分析如何根据一些过去条件的好坏来选择使用不同嵌套查询关键字。

##### 1）找出年龄在35岁以上，rating>5的，一个月内，没有预定红色船只水手的名字；

```sql
select s.name
from Sailors s
where s.age > 35 and s.rating > 5 and s.sid not in (
	select sid 
    from Reaserves, Boats 
    where datediff(day.today, day) <= 30 and color = 'red'
);
```

##### 2）找出年龄在35岁以上，rating>5的，一个月内，同时预定了红色船和绿色船的水手姓名；

```sql
select s.name
from Sailors s
where s.age > 35 and s.rating > 5 and s.sid in (
	select sid 
    from Reaserves r1 left join Reaserves r2 
    on r1.sid = r2.sid
    where r1.bid = (select bid from Boats where color = 'red')
    	and r2.bid = (select bid from Boats where color = 'green')
);
```

##### 3）找出预定了所有船的水手的名字

```sql
select s.name
from Sailors s, Boats b, Reverses r
where s.sid = r.sid 
	and count(distinct(r.bid)) = count(b.bid);
```

#### 二、选课情况

表结构如下：

```
teacher(teacher_id, teacher_name, teacher_email, teacher_gender, teacher_title)
course(course_id, course_name, teacher_id, term, year)
student(student_id, student_name, student_grade, student_gender)
course_election(ce_id, course_id, student_id, marks)
```

##### 1）辅导员想要了解其所在年级学生的课程选修数量是否合理，请查询该院系每个三年级学生2015年第一学期的选修课程数量，查询学生的student_id，student_name，student_grade，以及选修课程数量

```sql
select s.student_id, s.student_name, s.student_grade, count(course_id)
from 
	student s left join course_election ce on s.student_id = ce.student_id
	left join course c on ce.course_id = c.course_id
where c.term = 1 and c.year = 2015 and s.student_grade = 3
group by s.student_id;
```

（瞎写的）

##### 2）为了方便查询,希望创建一个课程视图,包括2015年第一学期的所有课程,包含课程表的所有字段,以及每门课的总选修人数。若没人选修,则选修人数为0。

```sql
create view class_choose as
select course.*, count(course_election.student_id) cnt
from course left join  course_election
on course.course_id = course_election.course_id
where course.term = 1 and course.year = 2015
group by course.course_id;
```

##### 3）教务处现在进行了一些修改,当有不及格的成绩录入时,需要对成绩进行规范处理。对于低于60分的成绩按照60分算,使用触发器完成相应的要求。

```sql
create trigger insert_grade_trigger
    before insert on course_election
    for each row
    begin
        if new.marks<60 then
           set new.marks=60;
        end if;
    end;
```

#### 三、商场关系模式

表结构如下：

```
store(store_id, store_name, store_ floor, room_no)
commodity(com_id, com_name, com_price, store_id)
saler(saler_id, saler_name, saler__gender, saler__age, store_id)
bill(bill_id, saler_id, com_id, purchase_quantity, total_price, bill_time)
```

其中，店铺表记录了该商场入驻的店铺信息,商品为每个店铺中销售的商品信息,销售员为店铺中的工作人员，流水账单表为为商场收银台交易的纪录， `bill time`交易发生的时间，为`datetime`类型,每个流水账单只包含了一种商品,不同类商品为不同的账单，`purchase_ quantity`数量为正整数
##### 1）在生成账单记录时, total_price是由传入的com_ id和purchase_quantity查询到相关的单价以及数量计算出来的，请完成这样一条插入。

```sql
drop procedure if exists m_insert;
DELIMITER $$
create PROCEDURE m_insert(in cd int,in q int)
begin
    insert into bill(com_id, purchase_quantity, total_price, bill_time)
    select cd, q, com_price*q, now()
    from commodity
    where com_id = cd;
end $$
```

##### 2）A店铺的老板想要了解一下店铺员工每天的销售业绩，请查询 store_id为"MCSA"的店铺里的所有员工在2021年3月4日的完成的交易笔数，以及每个员工完成的总交易额。

```sql
select count(total_price) as cnt, sum(total_price) as total
from saler s left join bill b on s.saler_id = b.saler_id
where s.store_id = 'MSCA' 
and date_format(b.bill_time, '%Y-%m-%d')='2021-03-14'
```

##### 3）商场的管理人员想了解2021年3月14日哪个店铺的交易额最大，查询其店铺名称，店铺所在楼层，店铺编号以及当天的交易额。

```sql
select s.store_name
from store s
where date_format(b.bill_time, '%Y-%m-%d')='2021-03-14' 
and s.store_id in (
	select s1.store_id, sum(s1.total_price) as total
    from store s1
    group by s1.store_id
    order by total DESC
    limit 1;
)
```

网上找的：

```sql
select  store_id,store_name,store_floor,ss
from
(select store.store_name,store_floor,store.store_id, sum(ifnull(total_price, 0)) ss
 from store
          left join saler on store.store_id = saler.store_id
          left join (
     select *
     from bill
     where date_format(bill.bill_time, '%Y-%m-%d') = '2021-03-14'
 ) mbill on saler.saler_id = mbill.saler_id
 group by store.store_id
) tmp
where ss=@max_value;
```

#### 社交应用

Circo是一款面向于大学生的群组类的社交应用,致力于让同学们能够体验到校园生活更加有趣有活力的一面，营造和谐自然的校园氛围。在这里,你可以关注与自己志同道合的小伙伴(User)，发布实时动态( Moment)，创建或者加入各种各样有趣的兴趣圈子(Group)，在圈子内Po上自己的美丽心情(red)，参与各种话题(Topic)的讨论

- 用户User：编号_id,昵称 nickname,头像 avatar,学校编号 schooled,创建时间 createdAt

- 学校 School：编号_id,学校名name

- 新鲜事 Moment：编号_id,发布者编号 author,文字内容 content,图片 Image,创建时间createdAt

- 新鲜事的点赞LikingMoment：用户编号 userid,新鲜事编号 momentId,创建时间 createdAt

- 话题 Topic 编号_id：话题名称name,热度heat,创建时间 createdAt,更新时间 updated
- 话题关系表 TopicRelation：话题编号 topica, moment编号 momentId

其中，话题热度根据时间推移按比例持续衰减，每24小时衰减10%，不足24小时则不进行衰减。

##### 1）查询热度前十的话题（话题id，名称，热度，moment数量，时间）

```sql
select 
	t._id, 
	t.name, 
	power(0.9, TIMESTAMPDIFF(SECOND, now(), t.createAt)/(24*3600)) as current_heart, 
	count(tr.moment_id), 
	t.createdAt 
from Topic t
join TopicRelation tr on t._id = tr.topicId
group by t._id
order by current_heart limit 0,10
```

##### 2）话题「陈振宇老师可能是软院最瘦的老师』的id为546，选出该话题下最新的20条moments的详细信息，包括 moment的编号、创建时间、图片、文字内容、我是否点赞(0代表未点赞,1代表已点赞)，用户的编号、昵称、头像，用户所属学校的编号、名称。

```sql
select czy._id, czy.createdAt, czy.Image, czy.content, if(count(lm.momentId), 1) as Iliked, u._id, u.nickname, u.avatar, u.schooled, sc.name
from (
	select m._id, m.createdAt, m.Image, m.content, m.author
    from Moment m left join TopicRelation tr on m._id = tr.momentId
    where tr._id = 546
    order by m.createdAt DESC
    limit 20
) czy
left join LikingMoment lm on czy._id = lm.momentId
left join User u on czy.author = u._id
left join School sc on u.schooled = sc._id;

```

##### 3）为了提高数据库效率，从不同角度简述有哪些优化措施

- 读写分离，垂直拆分，水平拆分
- 建立索引，数据分区
- 合理配置数据库
- 优化sql语句，避免全表扫描
- 使用表变量代替临时表

## 2022 重点

#### 关系理论

数据库中的表描述了关系，表的字段之间存在关系；从理论上保证一致性；

##### 1）为什么说关系数据库比层状/网状数据库更科学？

- 层次性数据库最早出现：存在逻辑嵌套，而不是线性排列，适用于部分场景，耦合性过强限制了我们对数据的自由操作；
- 网状数据库（多层次链接）：灵活很多，但是数据操作依然困难；
- 关系型数据库在灵活性、数据访问、数据的组织找到了很好的平衡点，说场景普适的存储方式，对于特定的存储不太合适；

##### 2）关系理论认为，数据中不应该有重复数据，记录之间也不存在顺序关系。在现实的关系型数据库中又是如何处理的？

关系理论不包含重复数据，不然无法保证一致性。然而很多中间结果集包含重复数据。因为：关系是处理无限数据集的，但是数据库处理的是有限数据集。有限数据集不仅需要保证正确，还需要提高效率。

额外：关系理论中，记录没有顺序。现实的关系型数据库中顺序存放记录使得效率提高；

##### 3）关系理论中的空值和实际关系型数据库中空值的处理有何差异？

“不知道”。空值对程序逻辑是危险的；存在空值意味着关系模型存在严重问题，动摇了查询优化的基础。

#### 索引

##### 1）位图索引的存储结构和用途

存储结构：

1. 位图索引的索引存储指向多行的指针；
2. 位图索引每次进行修改都会锁住全部的索引；

用途：

1. 相异基数低：字段可以取用的值比较少；
2. 大量临时查询的聚合；

##### 2）函数索引的含义和用途

含义：对$F(x)$的值构建索引，在通过对索引读取$x$所指向的记录行；

用途：

1. 不区分大小写的查询：使用函数输入；
2. T、F的巨大差异下的索引：如何找到少量的F；
3. 有选择的唯一性：Active的活动的名称不能相同；

##### 3）反向键索引或逆向索引的含义和用途

含义：将索引的字段翻转过来作为索引的键值；

用途：用来解决高并发下的系统生成键的创建和插入问题；

##### 4）还知道什么索引？

B+树索引、哈希索引、聚簇索引、辅助索引、稀疏索引（部分数据建立索引）、密集索引（全部）

##### 5）B树索引的结构和使用方式

有K个子树的中间结点包含K个元素，每个节点不保存数据只保存索引，所有的数据都存储在叶节点；

所有叶节点中包含了元素的信息，还有指向元素记录的指针，并且叶节点本身按照关键字大小从小到大的顺序连接；

使用方式是根据目标元素在B树中二分查找。

##### 6）何时该使用B树索引，并分别说明原因；并详细说明为什么系统的为外键构建索引是普遍的要求？

何时使用：

- 仅需要通过索引访问基本表的一部分（检索的结果集与集体的百分比低于10%）
- 如果处理表的多列，可以使用索引而不使用表；

为什么系统的为外键构建索引是普遍的要求：

- 建立外键索引可以更快速地保证数据的一致性：比如A持有B的外键，B删除记录时需要检查A中相应的行；否则，需要对A全表遍历；
- 建立外键索引可以避免死锁：如上所述，对A全表遍历时间很长，导致其他进程与之死锁，导致双双失败；

##### 7）针对6）有没有例外情况？如果有请简要说明情况

如果表很小或者很少被修改，则不必建立；因为使用索引非常占用磁盘空间；

##### 8）请描述Oracle中一种类似于B树索引结构的物理组织形式索引组织表（IOT）的基本结构和应用范围

其中的记录是排序，按主键有序的。IOT中每个叶节点既有每行的主键值，又有非主键值。

数据的存放是严格规定的， 记录的存放是排序的，查询效率非常高。数据插入以前其实就已经确定了其位置，所以不管插入的先后顺序，它在那个物理上的哪个位置与插入的先后顺序无关。这样在进行查询的时候就可以少访问很多 blocks，但是插入的时候，速度就比普通的表要慢一些。

应用范围：经常查找的表；经常通过主键访问的表；按顺序进行物理存贮；构建自己的索引结构；对主键或者唯一键区间查询、分类查询；

不适用：经常更新的表；不经常使用主键访问的表；

#### 数据库事务

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 未提交读 | ✅    | ✅          | ✅    |
| 已提交读 | ❌    | ✅          | ✅    |
| 可重复读 | ❌    | ❌          | ✅    |
| 可串行化 | ❌    | ❌          | ❌    |

**脏读**：当一个事务读取到另一个事务修改但未提交的数据时，就可能发生脏读。

- 指读到了其他事务未提交的数据；

**不可重复读**：在当执行SELECT操作时没有获得读锁或SELECT操作执行完后马上释放了读锁；另外一个事务对数据进行了更新，读到了不同的结果；

- 读到了其他事务已提交的数据；

**幻读**：不可重复读的一种特殊情况；

- 不可重复读针对的是UPDATE，而幻读针对的是DELETE和INSERT；

**未提交读：**最低的隔离级别，在这种隔离级别下，如果一个事务已经开始写数据，则另外一个事务则**不允许同时进行写操作，但允许其他事务读此行数据**。

|               事务1               |                事务2                 |
| :-------------------------------: | :----------------------------------: |
| SELECT id FROM users WHERE id = 1 |                                      |
|              结果是1              |                                      |
|                                   | UPDATE users SET id = 2 WHERE id = 1 |
| SELECT id FROM users WHERE id = 1 |                                      |
|              结果是2              |                                      |
|                                   |                COMMIT                |

**已提交读**：读取数据的事务**允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行，会对该写锁一直保持直到到事务提交**；

|               事务1               |                事务2                 |
| :-------------------------------: | :----------------------------------: |
| SELECT id FROM users WHERE id = 1 |                                      |
|              结果是1              |                                      |
|                                   | UPDATE users SET id = 2 WHERE id = 1 |
| SELECT id FROM users WHERE id = 1 |                                      |
|              Waiting              |                                      |
|                                   |              ROLLBACK;               |
| SELECT id FROM users WHERE id = 1 |                                      |
|              结果是1              |                                      |

但是仍然不可重复读。

**可重复读**：介于已提交读和可串行化之间的一种隔离级别。

**可串行化**：它要求在选定对象上的读锁和写锁保持到事务结束后才能释放，因为锁串行化的，所以效率比较低。

理论上，可重复读无法避免幻读，实际上几乎不会产生幻读。

#### 高并发和大数据量

##### 1）锁的解决方案是什么样的？

- 不要随便使用表级锁，尽量使用细粒度锁；
- 只有使用了索引才能使用行锁；
- 尽量缩短加锁时间
- 避免SQL上的循环处理；
- 减少程序和数据库之间的交互次数；
- 先roll back，提前释放锁；

##### 2）解决资源竞争的方法有哪些？

- DBA解决方案：与业务逻辑弱相关或无关
  - 事务空间：调整事物锁占空间的大小，事务条目占用是重要原因，DBA可以增加分配给事务条目的空间来解决；
  - 可用列表：insert操作在不同物理块中，可以借助存储管理手段；
- 架构解决方案：
  - 分区；
  - 逆序索引；减少竞争点
  - 索引组织表：原本资源竞争包括基本表和索引，但是现在索引和基本表合并了，可以降低冲突发生的位置；
- 开发解决方案
  - 调节并发数：限制最高的session数量；多加session反倒会增加管理成本；
  - 不适用系统产生键：如果键没有意义，不妨使用随机值，range需要足够大；碰撞